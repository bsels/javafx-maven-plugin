package com.github.bsels.javafx.maven.plugin;

import com.github.bsels.javafx.maven.plugin.parameters.AdditionalBinary;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Execute;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
import org.apache.maven.toolchain.ToolchainManager;
import org.codehaus.plexus.archiver.Archiver;
import org.codehaus.plexus.archiver.util.DefaultFileSet;
import org.codehaus.plexus.languages.java.jpms.LocationManager;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

/// Represents a Mojo for generating a JavaFX runtime image using the `jlink` tool.
/// This Mojo handles the configuration, execution, and customization of the runtime
/// image generation process, including managing output directories, launcher scripts,
/// and optional zipping of the application runtime image for distribution.
/// The class uses various configuration options to define the behavior of the `jlink` tool,
/// such as compression, stripping debug information, no-header files, no-man pages, and
/// verbose output. It also provides the ability to patch launcher scripts with custom JVM
/// options and command-line arguments.
/// Primary tasks handled by this Mojo include:
/// - Validating configuration options and required parameters.
/// - Constructing and executing the `jlink` command.
/// - Cleaning up output directories prior to image generation.
/// - Patching launcher scripts for additional customization.
/// - Optionally archiving the runtime image into a ZIP format for distribution.
/// This class extends the `BaseJavaFXMojo` class to inherit common functionality
/// for JavaFX Maven plugin MoJo implementations.
@Mojo(name = "jlink", requiresDependencyResolution = ResolutionScope.RUNTIME)
@Execute(phase = LifecyclePhase.PROCESS_CLASSES)
public final class JavaFXJlinkMojo extends BaseJavaFXMojo {
    /// A regular expression predicate used to validate and match Java logging configuration lines
    /// specifically related to the `java.util.logging.SimpleFormatter` format. This configuration
    /// is often found in logging properties files and is used to define the log message formatting.
    ///
    /// The pattern matches lines that:
    /// - Start with an optional `#` (indicating a commented-out property).
    /// - May include optional whitespace before the property declaration.
    /// - Contain the `java.util.logging.SimpleFormatter.format` property assignment.
    ///
    /// This is used to identify and potentially modify logging format properties in configuration files.
    private static final Predicate<String> LOG_FORMAT_REGEX = Pattern.compile(
            "^#?\\s*java.util.logging.SimpleFormatter.format=.*$"
    ).asMatchPredicate();
    /// Represents the special variable used to reference all command-line arguments passed
    /// to a script or executable within a launcher or shell environment.
    /// This variable is specifically used during jlink executions to include all arguments
    /// transparently when invoking the generated runtime or application.
    /// It is typically referenced in shell scripts, batch files, or configuration files
    /// during the process of creating a runtime image or launcher for JavaFX applications.
    private static final String COMMAND_ARGS_VAR = "$@";
    /// Represents the environment variable prefix for specifying VM options
    /// to be passed to the `jlink` tool during the runtime image generation process.
    /// This variable can be used to configure specific JVM behaviors or settings
    /// for the runtime image being created by `jlink`. It ensures that the appropriate
    /// Java VM options are included in the generated image or launcher scripts where applicable.
    private static final String JLINK_VM_OPTIONS = "JLINK_VM_OPTIONS=";
    /// Defines the VM options for the `jlink` process on Windows platforms.
    /// This is used as part of the launcher script configuration to set JVM-specific options
    /// when working with the JavaFX runtime image generated by the `jlink` tool.
    /// The value represents the environment variable assignment syntax specific to Windows systems.
    private static final String WIN_JLINK_VM_OPTIONS = "set JLINK_VM_OPTIONS=";
    /// A static, immutable set of strings representing valid compression options for the jlink tool.
    /// The set is a combination of:
    /// - Strings "0", "1", and "2" (Deprecated).
    /// - Strings formatted as "zip-<n>", where <n> is a number from 0 to 9.
    /// These options are used to define compression levels when creating modular runtime images
    /// with the jlink plugin. Each value corresponds to a specific compression strategy supported
    /// by the jlink utility.
    private static final Set<String> COMPRESS_OPTIONS = Stream.concat(
            IntStream.rangeClosed(0, 2).mapToObj(String::valueOf),
            IntStream.rangeClosed(0, 9).mapToObj(index -> String.format("zip-%d", index))
    ).collect(Collectors.toSet());
    /// Represents the default directory name where compiled application binaries
    /// or runtime images will be stored during the `jlink` execution process.
    /// This constant serves as the output folder location relative to the working
    /// directory for certain tasks, such as creating runtime images or application
    /// launchers. It is used internally to construct paths for file and directory
    /// operations during project builds.
    private static final String BIN_DIRECTORY = "bin";
    /// Represents the name of the configuration directory used in the
    /// application or build process. This directory typically contains
    /// configuration files or settings required for the execution or
    /// packaging of the JavaFX application runtime image.
    /// The constant is used to define and manage paths related to the
    /// configuration phase of the `jlink` process or other build-related
    /// operations within the `JavaFXJlinkMojo` class.
    private static final String CONF_DIRECTORY = "conf";
    /// File name of the logging configuration properties file used by the JavaFXJlinkMojo class.
    /// This file contains logging-related settings that configure the logging behavior during
    /// the execution of the plugin.
    /// It serves as a reference to locate and utilize the specific logging configuration file
    /// required for proper logging output when running associated processes.
    private static final String LOGGING_PROPERTIES_FILE = "logging.properties";
    /// Represents the file extension for a ZIP archive.
    /// This constant is used throughout the class to identify or create
    /// files with the `.zip` extension, particularly during the application
    /// packaging process.
    private static final String ZIP_EXTENSION = ".zip";
    /// Defines a system property key for configuring the log format used by the `java.util.logging.SimpleFormatter`.
    /// This property allows the user to specify a custom formatting string for log messages.
    /// The value assigned to this constant represents the key for the `SimpleFormatter.format` property
    /// that can be used within the Java Logging API configuration to control message formatting behavior.
    /// Example formats for this property may include timestamps, log levels, logger names,
    /// source method information, and the actual log message itself. The format string can be defined using
    /// standard patterns accepted by the `SimpleFormatter`.
    /// This property typically impacts applications relying on the default Java logging mechanism
    /// and can be adjusted for enhanced logging customization and clarity in both development and production environments.
    private static final String JAVA_UTIL_LOGGING_SIMPLE_FORMATTER_FORMAT = "java.util.logging.SimpleFormatter.format=%s";
    /// Represents the `Archiver` instance used for creating ZIP archives of the application.
    /// This utility is responsible for compressing specified files and directories into
    /// a ZIP archive format, which can then be distributed as part of the JavaFX runtime image.
    /// The `Archiver` is typically used in the zipping process of the application or any related
    /// resources during the execution of the `JavaFXJlinkMojo` plugin.
    /// It plays a crucial role in the following scenarios:
    /// - Packaging application resources into a distributable ZIP archive.
    /// - Supporting the creation of compressed distributions as an optional step in the JLink build pipeline.
    /// - Ensuring efficient storage and portability of final build outputs.
    private final Archiver zipArchiver;
    /// Represents the build output directory for the project.
    /// This directory is typically where the build artifacts, such as compiled classes
    /// and packaged outputs, are generated.
    /// The value of this field is automatically populated using the build system's
    /// configuration and typically resolves to the default project build directory.
    /// This field is marked as read-only and required, ensuring that it must be
    /// properly configured before execution.
    /// By default, the value is derived from `${project.build.directory}`.
    @Parameter(readonly = true, required = true, defaultValue = "${project.build.directory}")
    Path buildDirectory;
    /// Specifies the launcher name for the JavaFX application.
    /// This parameter is used to define the application's entry point or launcher that is utilized
    /// during the build process. It corresponds to the "javafx.launcher" property and can be configured
    /// in the Maven plugin configuration if needed.
    @Parameter(property = "javafx.launcher")
    String launcher;
    /// Specifies the path to the `jlink` executable to be used during the build process.
    /// By default, this is set to "jlink", which assumes that the `jlink` tool is
    /// available in the system's PATH.
    /// This parameter can be overridden using the property `javafx.jlinkExecutable`
    /// in the Maven configuration if a custom path to the `jlink` executable is required.
    @Parameter(property = "javafx.jlinkExecutable", defaultValue = "jlink")
    String jlinkExecutable;
    /// Represents the name to be used for the generated ZIP file when creating a custom runtime image
    /// using the JavaFX JLink plugin. This variable is typically configured as part of the Maven plugin
    /// parameters, allowing users to specify a custom output filename for the ZIP archive that contains
    /// the resulting JLink image.
    /// This field is mapped to the Maven property `javafx.jlinkZipName`, enabling configuration
    /// through the project POM or command-line arguments.
    @Parameter(property = "javafx.jlinkZipName")
    String jlinkZipName;
    /// The name of the directory to be created as the output of the jlink tool.
    /// This is the name of the image containing the runtime and application modules.
    /// Configured via the Maven property `javafx.jlinkImageName`.
    /// Default value is "image".
    @Parameter(property = "javafx.jlinkImageName", defaultValue = "image")
    String jlinkImageName;
    /// Specifies the path to the directory containing the JavaFX modular runtime platform (jmods).
    /// This parameter is used during the generation of a custom runtime image via the JLink tool.
    /// It points to the location where the required JavaFX jmod files are stored. These jmod files
    /// are necessary for including JavaFX modules in the runtime image.
    /// The value of this path can be provided as a Maven property using `javafx.jmodsPath`.
    @Parameter(property = "javafx.jmodsPath")
    String jmodsPath;
    /// Strips debug information out, equivalent to <code>-G, --strip-debug</code>,
    /// default false
    @Parameter(property = "javafx.stripDebug", defaultValue = "false")
    boolean stripDebug;
    /// Strip Java debug attributes out, equivalent to <code>--strip-java-debug-attributes</code>,
    /// default false
    @Parameter(property = "javafx.stripJavaDebugAttributes", defaultValue = "false")
    boolean stripJavaDebugAttributes;
    /// Compression level of the resources being used, equivalent to:
    /// <code>-c, --compress=level</code>., default 0
    @Parameter(property = "javafx.compress", defaultValue = "0")
    String compress;
    /// Remove the <code>includes</code> directory in the resulting runtime image,
    /// equivalent to: <code>--no-header-files</code>, default false
    @Parameter(property = "javafx.noHeaderFiles", defaultValue = "false")
    boolean noHeaderFiles;
    /// Remove the <code>man</code> directory in the resulting Java runtime image,
    /// equivalent to: <code>--no-man-pages</code>, default false
    @Parameter(property = "javafx.noManPages", defaultValue = "false")
    boolean noManPages;
    /// Add the option <code>--bind-services</code> or not, default false.
    @Parameter(property = "javafx.bindServices", defaultValue = "false")
    boolean bindServices;
    /// <code>--ignore-signing-information</code>, default false
    @Parameter(property = "javafx.ignoreSigningInformation", defaultValue = "false")
    boolean ignoreSigningInformation;
    /// Turn on verbose mode, equivalent to: <code>--verbose</code>, default false
    @Parameter(property = "javafx.jlinkVerbose", defaultValue = "false")
    boolean jlinkVerbose;

    /// Constructs a new instance of JavaFXJlinkMojo with the specified dependencies.
    ///
    /// @param locationManager  the LocationManager instance responsible for locating and managing paths and resources.
    /// @param toolchainManager the ToolchainManager instance responsible for managing and resolving toolchains.
    /// @param zipArchiver      the ZipArchiver instance used for creating zip archives of the application runtime image.
    @Inject
    public JavaFXJlinkMojo(
            LocationManager locationManager,
            ToolchainManager toolchainManager,
            @Named("zip")
            Archiver zipArchiver
    ) {
        super(locationManager, toolchainManager);
        this.zipArchiver = zipArchiver;
    }

    /// Executes the `jlink` Mojo to create a JavaFX runtime image.
    /// The execution process involves multiple steps:
    ///
    ///     - Validates the required parameters such as the `jlinkExecutable` and `baseDirectory`.
    ///     - If the `skip` flag is set, the execution is skipped with an informational log.
    ///     - Initializes the plugin with resolved paths and configurations.
    ///     - Handles the working directory by creating it if it does not yet exist.
    ///     - Constructs and executes the `jlink` command to create the runtime image.
    ///     - Optionally creates a launcher or zips the application if specified.
    ///
    /// Any errors occurring during the execution (e.g., invalid configurations, I/O issues, or process failure) will result
    /// in exceptions thrown with appropriate error messages.
    ///
    /// @throws MojoExecutionException if a configuration is invalid, required paths or parameters are missing, or
    ///                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          an I/O error occurs during the process.
    /// @throws MojoFailureException   if the `jlink` command execution or linking process fails with a non-zero exit code.
    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        if (skip) {
            getLog().info("Skipping execution of JavaFX run");
            return;
        }
        if (isEmpty(jlinkExecutable)) {
            throw new MojoExecutionException("JavaFX jlink executable is not specified");
        }
        if (baseDirectory == null) {
            throw new MojoExecutionException("JavaFX base directory is not specified");
        }

        getLog().info("Linking JavaFX application");
        init(
                Optional.of(Paths.get(jlinkExecutable))
                        .map(Path::getParent)
                        .map(Path::getParent)
                        .orElse(null)
        );
        handleWorkingDirectory();

        List<String> command = getJLinkCommand();
        getLog().info("Executing command: " + String.join(" ", command));
        ProcessBuilder builder = new ProcessBuilder(command)
                .directory(workingDirectory.toFile())
                .inheritIO();
        builder.environment().putAll(System.getenv());

        try {
            Process process = builder.start();
            int errorCode = process.waitFor();
            if (errorCode != 0) {
                getLog().error("Error: Could not link JavaFX application, exit code: %d".formatted(errorCode));
                throw new MojoFailureException("Error: Could not link JavaFX application");
            }
        } catch (InterruptedException | IOException e) {
            throw new MojoExecutionException("Error: Could not link JavaFX application", e);
        }

        copyAdditionalBinariesToBinaryFolder();
        patchLauncherScripts();
        patchLoggingFormat();
        zipApplication();
    }

    /// Copies additional binary files to the binary folder within the build directory.
    ///
    /// This method iterates over a list of additional binaries and copies each binary
    /// to the determined binary folder location. Existing files in the target directory
    /// are replaced if duplicates exist, and file attributes are preserved during the copy.
    ///
    /// @throws MojoExecutionException if an I/O error occurs during the copying process.
    ///                                The exception includes details about the source and
    ///                                destination paths that caused the failure.
    private void copyAdditionalBinariesToBinaryFolder() throws MojoExecutionException {
        if (isEmpty(additionalBinaries)) {
            return;
        }
        getLog().info("Copying additional binaries to binary folder");
        Path binDirectory = buildDirectory.resolve(jlinkImageName, BIN_DIRECTORY);
        for (AdditionalBinary additionalBinary : additionalBinaries) {
            Path inputPath = additionalBinary.getLocation();
            Path outputPath = binDirectory.resolve(inputPath.getFileName());
            try {
                getLog().info("Copying additional binary: %s to %s".formatted(inputPath.toAbsolutePath(), outputPath));
                Files.copy(inputPath, outputPath, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
            } catch (IOException e) {
                throw new MojoExecutionException("Unable to copy `%s` to `%s`".formatted(inputPath, outputPath), e);
            }
        }
    }

    /// Constructs a list of commands needed to execute the `jlink` tool with the specified configuration options.
    /// The command list includes the executable path, module paths, output directory, and any additional options
    /// such as stripping debug information, compression, or module binding based on the class-level configurations.
    ///
    /// @return a list of strings representing the `jlink` command and its arguments
    /// @throws MojoExecutionException if a required configuration (e.g., module descriptor) is missing or if there are issues with cleanup or invalid options
    private List<String> getJLinkCommand() throws MojoExecutionException {
        List<String> command = new ArrayList<>(getExecutable(jlinkExecutable));
        if (!isEmpty(modulePathElements)) {
            command.add("--module-path");
            String modules = String.join(File.pathSeparator, modulePathElements);
            if (!isEmpty(jmodsPath)) {
                getLog().debug("Using custom jmods path: " + jmodsPath);
                modules = jmodsPath + File.pathSeparator + modules;
            }
            command.add(modules);
            command.add("--add-modules");
            if (moduleDescriptor != null) {
                command.add(createAddModulesString());
            } else {
                throw new MojoExecutionException("jlink requires a module descriptor");
            }
        }
        command.add("--output");
        Path outputDirectory = buildDirectory.resolve(jlinkImageName);
        getLog().debug("Using output directory: " + outputDirectory.toAbsolutePath());
        if (Files.exists(outputDirectory)) {
            cleanupOutputDirectory(outputDirectory);
        }
        command.add(outputDirectory.toAbsolutePath().toString());

        if (stripDebug) {
            command.add("--strip-debug");
        }
        if (stripJavaDebugAttributes) {
            command.add("--strip-java-debug-attributes");
        }
        if (!isEmpty(compress)) {
            if (!COMPRESS_OPTIONS.contains(compress)) {
                getLog().warn("Invalid compression option: " + compress);
                getLog().warn("Valid compression options are: " + String.join(", ", COMPRESS_OPTIONS));
                throw new MojoExecutionException("Invalid compression option: " + compress);
            }
            command.add("--compress=" + compress);
        }
        if (noHeaderFiles) {
            command.add("--no-header-files");
        }
        if (noManPages) {
            command.add("--no-man-pages");
        }
        if (bindServices) {
            command.add("--bind-services");
        }
        if (ignoreSigningInformation) {
            command.add("--ignore-signing-information");
        }
        if (jlinkVerbose) {
            command.add("--verbose");
        }

        if (!isEmpty(launcher)) {
            command.add("--launcher");
            String moduleMainClass;
            if (mainClass.contains("/")) {
                moduleMainClass = mainClass;
            } else {
                moduleMainClass = moduleDescriptor.name() + "/" + mainClass;
            }
            command.add(launcher + "=" + moduleMainClass);
        }
        return command;
    }

    /// Cleans up the specified output directory by deleting its contents recursively.
    /// If an error occurs during the deletion process, a [MojoExecutionException] is thrown.
    ///
    /// @param outputDirectory the path to the output directory to be cleaned up
    /// @throws MojoExecutionException if the output directory cannot be cleaned up
    private void cleanupOutputDirectory(Path outputDirectory) throws MojoExecutionException {
        try (Stream<Path> filesToRemove = Files.walk(outputDirectory)) {
            filesToRemove.sorted(Comparator.reverseOrder())
                    .forEach(file -> {
                        try {
                            Files.deleteIfExists(file);
                        } catch (IOException e) {
                            throw new RuntimeException(e);
                        }
                    });
        } catch (RuntimeException | IOException e) {
            Throwable exception = e;
            if (exception instanceof RuntimeException) {
                exception = exception.getCause();
            }
            throw new MojoExecutionException("Error: Could not remove existing output directory", exception);
        }
    }

    /// Updates the JavaFX launcher scripts to include specified JVM options and command-line arguments.
    /// This method processes the primary launcher script, and if the operating system is determined
    /// to be Windows, it also processes the corresponding `.bat` launcher script. The scripts are
    /// modified based on the configurations provided within the class, such as JVM options and
    /// command-line arguments.
    /// The method utilizes [#patchLauncherScript(String)] to apply the modifications to the
    /// individual launcher scripts. If the script does not exist, a warning is logged, and no changes are made.
    ///
    /// @throws MojoExecutionException if an error occurs during the modification of the launcher scripts,                                                                                                                                          such as an I/O issue or invalid script content.
    private void patchLauncherScripts() throws MojoExecutionException {
        if (isEmpty(launcher)) {
            return;
        }
        getLog().info("Creating launcher");
        getLog().info("Patching launcher scripts");
        patchLauncherScript(launcher);
        if (isWindowsOs()) {
            patchLauncherScript(launcher + ".bat");
        }
        getLog().info("Launcher scripts patched successfully");
    }

    /// Updates the specified launcher script to include JVM options and command-line arguments
    /// defined by the class configuration. The method reads the original script line-by-line,
    /// applies transformations to include the specified options and arguments, and writes the
    /// updated content back to the launcher script.
    /// If the launcher script does not exist, a warning is logged and no further action is taken.
    /// If no options or arguments are specified, the script remains unchanged.
    ///
    /// @param launcher the name of the launcher script file to be updated; must not be null or empty
    /// @throws MojoExecutionException if an I/O error occurs while reading or writing the launcher script
    private void patchLauncherScript(String launcher) throws MojoExecutionException {
        Path launcherScript = buildDirectory.resolve(jlinkImageName, BIN_DIRECTORY, launcher);
        if (!Files.exists(launcherScript)) {
            getLog().warn("Launcher script does not exist: " + launcherScript.toAbsolutePath());
            return;
        }

        Stream<String> optionsStream = Stream.of(ENABLE_NATIVE_ACCESS_JAVAFX);
        if (!isEmpty(additionalBinaries)) {
            optionsStream = Stream.concat(
                    optionsStream,
                    additionalBinaries.stream()
                            .map(this::extractPropertyForBinary)
            );
            getLog().debug("Added %d additional binaries".formatted(additionalBinaries.size()));
        } else {
            getLog().debug("No additional binaries specified for launcher script");
        }
        if (!isEmpty(options)) {
            optionsStream = Stream.concat(
                    optionsStream,
                    options.stream()
                            .gather(CheckAndCast.of(String.class))
            );
            getLog().debug("Add JVM options to launcher script");
        } else {
            getLog().debug("No JVM options specified for launcher script");
        }
        String optionsString = optionsStream.collect(Collectors.joining(" "));
        getLog().debug("Launcher script options: " + optionsString);
        Function<String, String> handleJvmOptions = line -> handleJvmOption(line, optionsString);

        Function<String, String> handleCommandlineArgs;
        if (!isEmpty(commandlineArgs)) {
            getLog().debug("Add commandline args to launcher script: " + String.join(" ", commandlineArgs));
            handleCommandlineArgs = this::handleCommandLineArgs;
        } else {
            getLog().debug("No commandline args specified for launcher script");
            handleCommandlineArgs = Function.identity();
        }

        List<String> updatedScript;
        try (Stream<String> lines = Files.lines(launcherScript)) {
            updatedScript = lines.map(handleJvmOptions)
                    .map(handleCommandlineArgs)
                    .toList();
            Files.write(launcherScript, updatedScript);
        } catch (IOException e) {
            throw new MojoExecutionException("Unable to patch launcher script", e);
        }
    }

    /// Extracts a formatted file path property for the given AdditionalBinary object.
    ///
    /// @param additionalBinary the AdditionalBinary instance from which to extract the file name.
    /// @return a string representation of the file path formatted as "./{fileName}".
    private String extractPropertyForBinary(AdditionalBinary additionalBinary) {
        getLog().debug("Adding %s to additional binaries".formatted(additionalBinary.getName()));
        Path fileName = additionalBinary.getLocation().getFileName();
        return "-D%s=./%s".formatted(additionalBinary.getMappedJavaProperty(), fileName);
    }

    /// Updates the logging configuration file to ensure the desired logging format is applied.
    /// This method checks for the existence of the logging properties file in the designated
    /// location. If the file exists, it reads its content, updates the logging format, and writes
    /// the updated configuration back to the file.
    ///
    /// If no matching logging format entry is found in the file, a default logging format entry
    /// is appended to the configuration. If the file does not exist, a warning is logged, and
    /// the method terminates without performing any modifications.
    ///
    /// @throws MojoExecutionException if an error occurs while reading or writing the logging
    ///                                                                                                                                                                                                                                                                                        configuration file.
    private void patchLoggingFormat() throws MojoExecutionException {
        if (isEmpty(loggingFormat)) {
            return;
        }
        getLog().info("Patching logging format in `conf/logging.properties` configuration file");
        Path loggingPropertiesFile = buildDirectory.resolve(jlinkImageName, CONF_DIRECTORY, LOGGING_PROPERTIES_FILE);
        if (!Files.exists(loggingPropertiesFile)) {
            getLog().warn("Logging format configuration file does not exist: %s".formatted(
                    loggingPropertiesFile.toAbsolutePath()
            ));
            return;
        }

        try (Stream<String> lines = Files.lines(loggingPropertiesFile)) {
            List<String> updateConfiguration = lines.map(this::replaceLoggingFormat)
                    .collect(Collectors.toCollection(ArrayList::new));
            boolean noneMatchFormat = updateConfiguration.stream()
                    .noneMatch(LOG_FORMAT_REGEX);
            if (noneMatchFormat) {
                updateConfiguration.addLast(JAVA_UTIL_LOGGING_SIMPLE_FORMATTER_FORMAT.formatted(loggingFormat));
            }
            Files.write(loggingPropertiesFile, updateConfiguration);
        } catch (IOException e) {
            throw new MojoExecutionException("Unable to patch configuration logging properties", e);
        }
    }

    /// Replaces the logging format within the given line if it matches a predefined logging format pattern.
    /// If the line matches the pattern defined by LOG_FORMAT_REGEX, it replaces the format using
    /// JAVA_UTIL_LOGGING_SIMPLE_FORMATTER_FORMAT and the current logging format configuration.
    /// Otherwise, it returns the original line unchanged.
    ///
    /// @param line the string line to be checked and modified if it matches the logging format pattern
    /// @return the modified line with the substituted logging format if a match is found, otherwise the original line
    private String replaceLoggingFormat(String line) {
        if (LOG_FORMAT_REGEX.test(line)) {
            return JAVA_UTIL_LOGGING_SIMPLE_FORMATTER_FORMAT.formatted(loggingFormat);
        }
        return line;
    }

    /// Handles substitution of a specific placeholder variable within a given command-line argument string.
    /// If the input string ends with the specified variable identifier, it replaces the variable with
    /// a combination of class-defined command-line arguments and the placeholder itself. If the variable
    /// is not present, the original string is returned unchanged.
    ///
    /// @param line the command-line string to be processed; must not be null
    /// @return the modified command-line string with substituted arguments if applicable;
    ///         otherwise, the original string
    private String handleCommandLineArgs(String line) {
        if (line.stripTrailing().endsWith(COMMAND_ARGS_VAR)) {
            return line.replace(COMMAND_ARGS_VAR, commandlineArgs + " " + COMMAND_ARGS_VAR);
        }
        return line;
    }

    /// Handles the JVM option line by appending the provided options string based on
    /// whether the line corresponds to UNIX or Windows JVM options.
    ///
    /// @param line          a string representing a line in the JVM options file
    /// @param optionsString the JVM options to be appended to the line
    /// @return the modified line with the appended options if applicable; otherwise, the original line
    private String handleJvmOption(String line, String optionsString) {
        boolean unixOptionsLine = JLINK_VM_OPTIONS.equals(line);
        boolean winOptionsLine = WIN_JLINK_VM_OPTIONS.equals(line);

        if (unixOptionsLine || winOptionsLine) {
            String lineWrapper = unixOptionsLine ? "'" : "";
            return line + lineWrapper + optionsString + lineWrapper;
        }
        return line;
    }

    /// Creates a zip archive of the application.
    /// This method compresses the application files into a ZIP archive for distribution.
    /// The path to the zipped application archive is determined via the `createApplicationZipArchive()` method.
    /// Upon successful creation, the ZIP archive is associated with the project's artifact.
    /// The following steps are performed:
    /// - Logs the beginning of the zipping process.
    /// - Calls the `createApplicationZipArchive()` method to generate the path of the ZIP archive.
    /// - Sets the created ZIP file as the project's artifact file.
    /// - Logs the successful completion of the zipping process.
    /// Note: Ensure that the required resources are in place before invoking this method to avoid runtime issues.
    private void zipApplication() throws MojoExecutionException {
        if (isEmpty(jlinkZipName)) {
            return;
        }
        getLog().info("Zipping application");
        Path applicationZip = createApplicationZipArchive();
        Optional.ofNullable(project)
                .map(MavenProject::getArtifact)
                .ifPresent(artifact -> artifact.setFile(applicationZip.toFile()));
        getLog().info("Application zipped successfully");
    }

    /// Creates a ZIP archive of the JavaFX application runtime image.
    /// This method compresses the application files from the `jlink` generated
    /// directory into a single ZIP file for distribution.
    /// The archive creation process involves the following steps:
    /// - Resolves the application build directory and runtime image directory.
    /// - Adds the runtime image files to the ZIP archive, ensuring all files and directories are included.
    /// - Sets the destination file for the archive in the build directory with the specified ZIP file name.
    /// - Creates the ZIP archive using the configured `zipArchiver` instance.
    /// If any error occurs during the archive creation process, an exception is thrown.
    ///
    /// @return the [Path] to the created ZIP archive containing the application runtime image
    /// @throws MojoExecutionException if an I/O error occurs during the archive creation process
    private Path createApplicationZipArchive() throws MojoExecutionException {
        Path imageDirectory = buildDirectory.resolve(jlinkImageName);
        zipArchiver.addFileSet(
                DefaultFileSet.fileSet(imageDirectory.toFile())
                        .prefixed("")
                        .includeExclude(null, null)
                        .includeEmptyDirs(true)
        );
        Path resultArchive = buildDirectory.resolve(jlinkZipName + ZIP_EXTENSION);
        zipArchiver.setDestFile(resultArchive.toFile());
        try {
            zipArchiver.createArchive();
        } catch (IOException e) {
            throw new MojoExecutionException("Unable to create ZIP archive", e);
        }
        return resultArchive;
    }

}
